/* cc1.h - compiler main                                ncc, the new c compiler

Copyright (c) 2021 Charles E. Youse (charles@gnuless.org). All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

#ifndef CC1_H
#define CC1_H

#include <stdlib.h>
#include <stdarg.h>

/* number of hash buckets in the string table. your intuition is
   correct on this: more buckets means more memory but faster. */

#define STRING_NR_BUCKETS 32

/* be more careful with the number of symbol buckets. entering and
   exiting scopes requires a traversal of all the buckets, so there
   are both time and space penalties for bumping this number up. */

#define SYMBOL_NR_BUCKETS       32

/* number of buckets used for mapping pseudo_regs to their respective
   symbols. the above caveat does not apply do these, but since only
   actual object symbols get registers, we shouldn't need as many. */

#define SYMBOL_NR_REG_BUCKETS   16

/* you know what this is... right? */

#define BITS_PER_BYTE 8

/* the maximum size of an object in bytes. the value is chosen such that
   MAX_SIZE * BITS_PER_BYTE can be represented in an int, and MAX_SIZE *
   MAX_SIZE * BITS_PER_BYTE won't overflow a long. this simplifies parsing
   static expressions and gives us breathing room in type_sizeof() and
   when processing struct definitions, and elsewhere. changing this would
   require a lot of rework, but there shouldn't be any reason for that. */

#define MAX_OBJECT_SIZE     (128 * 1024 * 1024)       /* 128MB */

typedef int error_type; /* WARNING/FATAL */

#define WARNING     0
#define FATAL       1

extern void error(error_type, char *, ...);

extern void *safe_malloc(size_t);

/* assembler labels are the internal labels generated by the compiler.
   they're simply sequential numbers that are prefixed to make them
   valid for the assembler, e.g., L1, L2 ... zero means "no label" */

typedef unsigned asm_label;

extern asm_label last_asm_label;

#define ASM_LABEL_PRINTF    "L%u"

#define ASM_LABEL_NEW()     (++last_asm_label)

/* everybody needs a boolean type (but it doesn't need to be
   poorly engineered into the language; looking at you, C99) */

typedef enum { FALSE, TRUE } bool; 

/* debugging command-line flags (see cc1.c for descriptions) */

extern bool debug_flag_d;
extern bool debug_flag_e;
extern bool debug_flag_g;
extern bool debug_flag_i;
extern bool debug_flag_l;
extern bool debug_flag_r;
extern bool debug_flag_s;
extern bool debug_flag_v;

/* the generally-useful constant-value container */

union con { long i; unsigned long u; double f; };

/* pseudo_regs with the high bit set are machine-independent.
   bits[30:21] hold the subscript for SSA/web numbering. the
   remaining bits[20:0] are defined by the target. note that
   we are limited to approximately 2 million pseudo registers
   per compilation and 1,000 subscripts per register. if these
   prove too limiting, we can expand the size of a pseudo_reg,
   but it must always remain unsigned. */

typedef unsigned pseudo_reg;

#define PSEUDO_REG_OUTPUT   "%u"

#define PSEUDO_REG_RESERVED     ( 0x80000000 )

#define PSEUDO_REG_CC           (  0 | PSEUDO_REG_RESERVED )
#define PSEUDO_REG_NONE         (  1 | PSEUDO_REG_RESERVED )
#define PSEUDO_REG_MEM          (  2 | PSEUDO_REG_RESERVED )

#define PSEUDO_REG_IDX_MASK     ( 0x7FE00000 )
#define PSEUDO_REG_IDX_SHIFT    21
#define PSEUDO_REG_BASE(r)      ((r) & ~PSEUDO_REG_IDX_MASK)

#define PSEUDO_REG_IDX(r)       (((r) & PSEUDO_REG_IDX_MASK) >>             \
                                       PSEUDO_REG_IDX_SHIFT)

#define PSEUDO_REG_SET_IDX(r, i)                                            \
    do {                                                                    \
        r = PSEUDO_REG_BASE(r);                                             \
        (r) |= ((i) << PSEUDO_REG_IDX_SHIFT);                               \
    } while (0)

#define PSEUDO_REGS_SAME_BASE(r1, r2)            (PSEUDO_REG_BASE(r1) ==    \
                                                  PSEUDO_REG_BASE(r2))

#endif /* CC1_H */

/* vi: set ts=4 expandtab: */
